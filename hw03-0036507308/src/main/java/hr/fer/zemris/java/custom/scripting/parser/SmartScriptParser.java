package hr.fer.zemris.java.custom.scripting.parser;

import hr.fer.zemris.java.custom.scripting.elems.Element;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantDouble;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantInteger;
import hr.fer.zemris.java.custom.scripting.elems.ElementFunction;
import hr.fer.zemris.java.custom.scripting.elems.ElementOperator;
import hr.fer.zemris.java.custom.scripting.elems.ElementString;
import hr.fer.zemris.java.custom.scripting.elems.ElementVariable;
import hr.fer.zemris.java.custom.scripting.lexer.Lexer;
import hr.fer.zemris.java.custom.scripting.lexer.LexerState;
import hr.fer.zemris.java.custom.scripting.lexer.Token;
import hr.fer.zemris.java.custom.scripting.lexer.TokenType;
import hr.fer.zemris.java.custom.scripting.nodes.DocumentNode;
import hr.fer.zemris.java.custom.scripting.nodes.EchoNode;
import hr.fer.zemris.java.custom.scripting.nodes.ForLoopNode;
import hr.fer.zemris.java.custom.scripting.nodes.Node;
import hr.fer.zemris.java.custom.scripting.nodes.TextNode;
import hr.fer.zemris.java.custom.collections.ArrayIndexedCollection;
import hr.fer.zemris.java.custom.collections.ObjectStack;


/**
 * Class parser is used for parsing {@link Token} objects generated by {@link Lexer} and storing them
 * in a tree-like structure.
 * 
 * @author Martina
 *
 */
public class SmartScriptParser {
	
	//first node in a tree
	private DocumentNode documentNode;
	
	//stack to help with tree constuction
	ObjectStack stack;
	
	
	/**
	 * Constructor that creates a new {@link Lexer} and delegates the parsing to {@link #parse(Lexer)} method.
	 * @param document	a String to be parsed
	 */
	public SmartScriptParser(String document) {
		documentNode = new DocumentNode();
		Lexer lexer = new Lexer(document);
		
		try {
			parse(lexer);
		}catch (Exception e) {
			throw new SmartScriptParserException();
		}
	}

	/** 
	 * Get's {@link Token} objects from the {@link Lexer} and creates corresponding elements.
	 * Creates a tree-like structure of elements parsed from a document.
	 * @param lexer	{@link Lexer} object to generate tokens from given document.
	 */
	private void parse(Lexer lexer) {
		
		int numOfForTokens = 0;
		int numOfEndTokens = 0;
		
		Token last; //last token gotten from a lexer
		stack = new ObjectStack(); //temporary structure to help generate a tree of objects
		
		stack.push(documentNode); //first node in a tree
		Node lastPushed = documentNode; //remembers which node was last pusned to the stack
		
		while (! (last = lexer.nextToken()).getType().equals(TokenType.EOF)) {
			
			//if last token is an open tag, check if tag name is OK and push the right node on the stack
			if (last.getType().equals(TokenType.TAG_START)) {
				
				lexer.setState(LexerState.EXTENDED);
				last = lexer.nextToken();
				
				//case tag name is =
				if (last.getType().equals(TokenType.OPERATOR) && last.getValue().equals("=")) {
					
					ArrayIndexedCollection collection = new ArrayIndexedCollection();
					
					while (!(last = lexer.nextToken()).getType().equals(TokenType.TAG_END)) {
						checkIfEnd(last);
						checkIfOkForEchoNodeAndAdd(last, collection);
					}
					Element[] elements = new Element[collection.size()];
					
					for (int i = 0; i < collection.size(); i++) {
						elements[i] = (Element) collection.get(i);
					}
					//create new EchoNode
					EchoNode node = new EchoNode(elements);
					lastPushed.addChildNode(node);
					
				// case tag name is FOR
				}else if (last.getType().equals(TokenType.VARIABLE) && last.getValue().toString().toUpperCase().equals("FOR")) {
					
					ArrayIndexedCollection helpCollection = new ArrayIndexedCollection();
					int index = 0;
					
					while (!(last = lexer.nextToken()).getType().equals(TokenType.TAG_END)) {
						checkIfEnd(last);
						
						checkIfOkForLoopNodeAndAdd(last, helpCollection, index);
						index++;
					}
					checkNumberOfElementsForLoop(helpCollection);
					
					Element[] elements = new Element[helpCollection.size()];
					
					for (int i = 0; i < helpCollection.size(); i++) {
						elements[i] = (Element) helpCollection.get(i);
					}
					
					ForLoopNode loopNode = new ForLoopNode ((ElementVariable)elements[0], elements[1], 
												elements[2], elements.length == 4 ? elements[3] : null);
					
					numOfForTokens++;
					
					stack.push(loopNode);
					lastPushed.addChildNode(loopNode);
					lastPushed = loopNode;
				
				// case tag name is END
				}else if (last.getType().equals(TokenType.VARIABLE) && last.getValue().toString().toUpperCase().equals("END")) {
					numOfEndTokens++;
					
					stack.pop();
					lastPushed = (Node) stack.peek();
					
					if (stack.isEmpty()) {
						throw new SmartScriptParserException();
					}
				//tag name can't be any other
				}else {
					throw new SmartScriptParserException();
				}
				
			}else if (last.getType().equals(TokenType.TEXT)) {
				lastPushed.addChildNode(new TextNode((String) last.getValue()));
			}	
				
			if (last.getType().equals(TokenType.TAG_END)) {
				lexer.setState(LexerState.BASIC);
			}
			
		}
		if (numOfEndTokens!=numOfForTokens) {
			throw new SmartScriptParserException();
		}
		
	}

	/**
	 * Checks if number of elements to add in a for-loop node is 3 or 4.
	 * @param helpCollection	collection in which the elements are stored
	 * @throws SmartScriptParserException if number of elements is not right
	 */
	private void checkNumberOfElementsForLoop(ArrayIndexedCollection helpCollection) {
		if (helpCollection.size() > 4 || helpCollection.size() < 3) {
			throw new SmartScriptParserException();
		}
	}
	
	/**
	 * Checks if parser has reached the EOF when it shouldn't have.
	 * @param token	token whose value is to be checked
	 * @throws SmartScriptParserException if EOF is reached
	 */
	private void checkIfEnd(Token token) {
		if (token.getValue().equals(null)) {
			throw new SmartScriptParserException();
		}
	}
	
	/**
	 * Checks if token value should be added and adds it to the temporary collection of elements.
	 * @param last	token of which value is to be checked
	 * @param helpCollection	temporary collection to store the elements
	 * @param index	 determines if value is to be stored as {@link ElementVariable } or something else
	 */
	private void checkIfOkForLoopNodeAndAdd(Token last, ArrayIndexedCollection helpCollection, int index) {
		if (index == 0) {
			if (last.getType().equals(TokenType.VARIABLE) && isValidVariableName(last.getValue().toString())) {
				helpCollection.add(new ElementVariable(last.getValue().toString())); 
			}
		}else {
			checkType(last, helpCollection);
		}
	}

	
	/**
	 * Checks if values of certain types match the rules for defining those values.
	 * @param last	token of which a value is to be checked
	 * @param tempCollection	collection to add values that are OK to
	 * @param index
	 * @throws SmartScriptParserException if type or value is not any of the allowed ones
	 */
	private void checkType(Token last, ArrayIndexedCollection tempCollection) {
		if (last.getType().equals(TokenType.FUNCTION) && isValidFunctionName(last.getValue().toString())) {
			tempCollection.add(new ElementFunction(last.getValue().toString()));
			
		}else if (last.getType().equals(TokenType.STRING)) {
			tempCollection.add(new ElementString(last.getValue().toString()));
			
		}else if (last.getType().equals(TokenType.VARIABLE) && isValidVariableName(last.getValue().toString())) {
			tempCollection.add(new ElementVariable(last.getValue().toString()));
			
		}else if (last.getType().equals(TokenType.DOUBLE) && isValidDoubleValue(last.getValue().toString())) {
			tempCollection.add(new ElementConstantDouble(Double.parseDouble(last.getValue().toString())));
			
		}else if (last.getType().equals(TokenType.INTEGER) && isValidIntegerValue(last.getValue().toString())) {
			tempCollection.add(new ElementConstantInteger(Integer.parseInt(last.getValue().toString())));
		}else if (last.getType().equals(TokenType.OPERATOR) && last.getValue().toString().length() == 1) {
			tempCollection.add(new ElementOperator(last.getValue().toString()));
		}
		else {
			throw new SmartScriptParserException("Invalid value!");
		}
		
	}

	/**
	 * Checks if value can be parsed into Integer.
	 * @param string string to be parsed
	 * @return <code>true</code> if value is <code>Integer</code>, <code>false</code> otherwise
	 */
	private boolean isValidIntegerValue(String string) {
		try {
			Integer.parseInt(string);
		}catch (NumberFormatException ex){
			return false;
		}
		return true;
	}

	/**
	 * Checks if value can be parsed into Double.
	 * @param string string to be parsed
	 * @return<code>true</code> if value is <code>Double</code>, <code>false</code> otherwise
	 */
	private boolean isValidDoubleValue(String string) {
		try {
			if (string.startsWith(".") || string.endsWith(".")) {
				return false;
			}
			Double.parseDouble(string);
		}catch (NumberFormatException ex){
			return false;
		}
		return true;
	}

	/**
	 * Checks if value can be used as valid name.
	 * @param string string to be checked
	 * @return <code>true</code> if value is valid function name, <code>false</code> otherwise
	 */
	private boolean isValidFunctionName(String string) {
		char[] array = string.toCharArray();
		
		for (char c : array) {
			if (!(Character.isLetter(c) || Character.isDigit(c) || c == '_')) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Checks if value can be used as valid variable name.
	 * @param string string to be checked
	 * @return <code>true</code> if value is valid variable name, <code>false</code> otherwise
	 */
	private boolean isValidVariableName(String string) {
		char[] array = string.toCharArray();
		if (!Character.isLetter(array[0])) {
			return false;
		}
		for (char c : array) {
			if (!(Character.isLetter(c) || Character.isDigit(c) || c == '_')) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Checks if value matches the conditions to be added as an element of an EchoNode and adds it
	 * @param zadnji token which is to be checked
	 * @param tempCollection a temporary collection to store the elements
	 * @param index	
	 */
	private void checkIfOkForEchoNodeAndAdd(Token last, ArrayIndexedCollection tempCollection) {
		checkType (last, tempCollection);
	}

	/**
	 * Gets this parser's document node, top node in the document tree.
	 * @return this parser's document node.
	 */
	public DocumentNode getDocumentNode() {
		return this.documentNode;
	}
	
	/**
	 * Method to reconstruct the document by visiting node tree in order.
	 * @param document a document node, first node in a tree
	 * @return	a string representation of reconstructed document content
	 */
	public static String createOriginalDocumentBody(Node document) {
		
		//if current node is DocumentNode, return what all of it's children would return
		if (document instanceof DocumentNode) {
			String s = "";
			for (int j = 0; j < document.numberOfChildren(); j++) {
				s += createOriginalDocumentBody(document.getChild(j)); //recursive call for each child this node has
			}
			return s;
		}
		
		// if current node is TextNode, return it's text
		if (document instanceof TextNode) {
			return ((TextNode)document).getText();
		}
		
		// if current node is EchoNode, return it's elements and put them in tags
		if (document instanceof EchoNode) {
			Element[] collection = ((EchoNode)document).getElements();
			//make for tag string representation and add it to the document reconstruction
			String s = "{$ = ";
			for (Element e : collection) {
				s = s + " " + getString(e);
			}
			return s + " $} ";
		}
		
		//if current node is ForLoopNode, add all of it's content in tags and concatenate all strings it's children return
		if (document instanceof ForLoopNode) {
			ForLoopNode node = (ForLoopNode)document;
			//make for tag string representation and add it to the document reconstruction
			String s = "{$ FOR" + " " + node.getVariable().asText() + " " + getString(node.getStartExpression()) + " " +
							getString(node.getEndExpression()) + " " +
								(node.getStepExpression()== null ? "" : getString(node.getStepExpression()));
			 s+= " $} ";
			for (int i = 0; i < node.numberOfChildren(); i++) {
				s += createOriginalDocumentBody(node.getChild(i));
			}
			return s + "{$ END $}";
		}
		
	return "";	
		
	}
	
	/**
	 * Method to get the right string form of element according to it's type.
	 * @param element	element to get the string form of
	 * @return	string representation of this document to
	 * 			add to the document reconstruction
	 */
	private static String getString(Element element) {
		if (element instanceof ElementString) {
			return "\"" + element.asText() + "\"";
		}
		if (element instanceof ElementFunction) {
			return "@"+ element.asText();
		}
		return element.asText();
	}
	
	
}
